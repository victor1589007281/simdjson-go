//+build !noasm !appengine gc
// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT

// 定义数据段 LCDATA1，包含一些常量数据
DATA LCDATA1<>+0x000(SB)/8, $0x5c5c5c5c5c5c5c5c
DATA LCDATA1<>+0x008(SB)/8, $0x5c5c5c5c5c5c5c5c
DATA LCDATA1<>+0x010(SB)/8, $0x5c5c5c5c5c5c5c5c
DATA LCDATA1<>+0x018(SB)/8, $0x5c5c5c5c5c5c5c5c
DATA LCDATA1<>+0x020(SB)/8, $0x2222222222222222
DATA LCDATA1<>+0x028(SB)/8, $0x2222222222222222
DATA LCDATA1<>+0x030(SB)/8, $0x2222222222222222
DATA LCDATA1<>+0x038(SB)/8, $0x2222222222222222
DATA LCDATA1<>+0x070(SB)/8, $0x0706050403020100
DATA LCDATA1<>+0x078(SB)/8, $0xffffffffffff0908
DATA LCDATA1<>+0x080(SB)/8, $0xff0f0e0d0c0b0aff
DATA LCDATA1<>+0x088(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x090(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x098(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0a0(SB)/8, $0xff0f0e0d0c0b0aff
DATA LCDATA1<>+0x0a8(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0b0(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0b8(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0c0(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0c8(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0d0(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0d8(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0e0(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0e8(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0f0(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x0f8(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x100(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x108(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x110(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x118(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x120(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x128(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x130(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x138(SB)/8, $0xffffffffffffffff
DATA LCDATA1<>+0x140(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x148(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x150(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x158(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x160(SB)/8, $0x0000000000220000
DATA LCDATA1<>+0x168(SB)/8, $0x2f00000000000000
DATA LCDATA1<>+0x170(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x178(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x180(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x188(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x190(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x198(SB)/8, $0x0000005c00000000
DATA LCDATA1<>+0x1a0(SB)/8, $0x000c000000080000
DATA LCDATA1<>+0x1a8(SB)/8, $0x000a000000000000
DATA LCDATA1<>+0x1b0(SB)/8, $0x00000009000d0000
DATA LCDATA1<>+0x1b8(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1c0(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1c8(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1d0(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1d8(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1e0(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1e8(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1f0(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x1f8(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x200(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x208(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x210(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x218(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x220(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x228(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x230(SB)/8, $0x0000000000000000
DATA LCDATA1<>+0x238(SB)/8, $0x0000000000000000

// 定义全局符号 LCDATA1，大小为 576 字节
GLOBL LCDATA1<>(SB), 8, $576
// 定义汇编函数 _parse_string_validate_only
TEXT ·_parse_string_validate_only(SB), $8-40

    // 函数开始，设置参数
    MOVQ src+0(FP), DI // 将 src 参数加载到 DI 寄存器，src 是指向待验证字符串的指针
    MOVQ maxStringSize+8(FP), SI // 将 maxStringSize 参数加载到 SI 寄存器，表示字符串的最大大小
    MOVQ str_length+16(FP), DX // 将 str_length 参数加载到 DX 寄存器，表示字符串的实际长度
    MOVQ dst_length+24(FP), CX // 将 dst_length 参数加载到 CX 寄存器，表示目标长度
    LEAQ LCDATA1<>(SB), BP // 将 LCDATA1 的地址加载到 BP 寄存器，LCDATA1 是常量数据的地址
    
    // 从 maxStringSize 中加载值到 r11 寄存器
    WORD $0x8b4c; BYTE $0x1e // mov    r11, qword [rsi] // 将 maxStringSize 的值加载到 r11
    WORD $0x854d; BYTE $0xdb // test    r11, r11 // 测试 r11 是否为零
    JE   LBB0_30 // 如果 r11 为零，跳转到标签 LBB0_30
    
    // 清零 esi 寄存器
    WORD $0xf631 // xor    esi, esi // 将 esi 寄存器清零
    
    // 加载常量数据到 SIMD 寄存器
    LONG $0x456ffdc5; BYTE $0x00 // vmovdqa    ymm0, yword 0[rbp] /* [rip + LCPI0_0] */ // 将常量数据加载到 ymm0 寄存器
    LONG $0x4d6ffdc5; BYTE $0x20 // vmovdqa    ymm1, yword 32[rbp] /* [rip + LCPI0_1] */ // 将另一个常量数据加载到 ymm1 寄存器
    
    // 计算指向 digit to value 的地址
    LONG $0x404d8d4c // lea    r9, 64[rbp] /* [rip + __ZL10digittoval] */ // 将 digit to value 的地址加载到 r9 寄存器
    
    // 计算指向 escape map 的地址
    LONG $0x40958d4c; WORD $0x0001; BYTE $0x00 // lea    r10, 320[rbp] /* [rip + __ZL10escape_map] */ // 将 escape map 的地址加载到 r10 寄存器
    
    // 将 rdi（src）值移动到 r13 寄存器
    WORD $0x8949; BYTE $0xfd // mov    r13, rdi // 将 src 的指针存储在 r13 中
    
    // 清零 r14d 寄存器
    WORD $0x3145; BYTE $0xf6 // xor    r14d, r14d // 将 r14d 清零
    
    // 将 rdi（src）值移动到 rax 寄存器
    WORD $0x8948; BYTE $0xf8 // mov    rax, rdi // 将 src 的指针存储在 rax 中

LBB0_2: // 标签 LBB0_2，表示代码的一个分支

    LONG $0x106ffec5               // vmovdqu    ymm2, yword [rax] 
    // 从 rax 指向的内存地址加载 256 位数据到 ymm2 寄存器

    LONG $0xd874edc5               // vpcmpeqb    ymm3, ymm2, ymm0
    // 比较 ymm2 和 ymm0 中的字节，结果存储在 ymm3 中，若相等则对应字节为 0xFF，否则为 0x00

    LONG $0xdbd7fdc5               // vpmovmskb    ebx, ymm3
    // 将 ymm3 中的掩码（0xFF 和 0x00）移动到 ebx 寄存器中，ebx 中的每一位表示对应字节是否相等

    LONG $0xd174edc5               // vpcmpeqb    ymm2, ymm2, ymm1
    // 再次比较 ymm2 和 ymm1 中的字节，结果存储在 ymm2 中

    LONG $0xe2d77dc5               // vpmovmskb    r12d, ymm2
    // 将 ymm2 中的掩码移动到 r12d 寄存器中

    WORD $0x438d; BYTE $0xff       // lea    eax, [rbx - 1]
    // 计算 ebx 的值减去 1，结果存储在 eax 中

    WORD $0x8544; BYTE $0xe0       // test    eax, r12d
    // 测试 eax 和 r12d 的值，设置标志位

    JNE  LBB0_3                    // 如果不相等，跳转到标签 LBB0_3

    LONG $0x24448d41; BYTE $0xff   // lea    eax, [r12 - 1]
    // 计算 r12 的值减去 1，结果存储在 eax 中

    WORD $0xd885                   // test    eax, ebx
    // 测试 eax 和 ebx 的值，设置标志位

    JE   LBB0_28                   // 如果相等，跳转到标签 LBB0_28

    WORD $0xd889                   // mov    eax, ebx
    // 将 ebx 的值移动到 eax 中

    LONG $0xbc0f4cf3; BYTE $0xf8   // tzcnt    r15, rax
    // 计算 eax 中最低有效位的零计数，并将结果存储在 r15 中

    LONG $0x74b60f43; WORD $0x013d // movzx    esi, byte [r13 + r15 + 1]
    // 从 r13 + r15 + 1 的内存地址加载一个字节到 esi 中，并进行零扩展

    LONG $0x75fe8348               // cmp    rsi, 117
    // 将 rsi 的值与 117 进行比较

    JNE  LBB0_26                   // 如果不相等，跳转到标签 LBB0_26

    WORD $0x8545; BYTE $0xe4       // test    r12d, r12d
    // 测试 r12d 的值，设置标志位

    JE   LBB0_8                    // 如果 r12d 为零，跳转到标签 LBB0_8

    WORD $0x8944; BYTE $0xe0       // mov    eax, r12d
    // 将 r12d 的值移动到 eax 中

    LONG $0xbc0f48f3; BYTE $0xf0   // tzcnt    rsi, rax
    // 计算 eax 中最低有效位的零计数，并将结果存储在 rsi 中

    WORD $0x2944; BYTE $0xfe       // sub    esi, r15d
    // 从 esi 中减去 r15d 的值

    WORD $0xfe83; BYTE $0x06       // cmp    esi, 6
    // 将 esi 的值与 6 进行比较

    JAE  LBB0_11                   // 如果 esi >= 6，跳转到标签 LBB0_11

    JMP  LBB0_30                   // 否则跳转到标签 LBB0_30

LBB0_28: // 标签 LBB0_28，表示代码的一个分支
    LONG $0x20c58349         // add    r13, 32
    // 将 r13 的值增加 32，可能用于移动到下一个字符串位置

    LONG $0x20c68349         // add    r14, 32
    // 将 r14 的值增加 32，可能用于更新某个计数或索引

    WORD $0x894c; BYTE $0xe8 // mov    rax, r13
    // 将 r13 的值移动到 rax 寄存器中

    JMP  LBB0_29            // 跳转到标签 LBB0_29

LBB0_26: // 标签 LBB0_26，表示代码的另一个分支
    LONG $0x163c8042; BYTE $0x00 // cmp    byte [rsi + r10], 0
    // 比较 rsi + r10 指向的字节是否为 0

    JE   LBB0_30            // 如果相等，跳转到标签 LBB0_30

    LONG $0x3d448d4b; BYTE $0x02 // lea    rax, [r13 + r15 + 2]
    // 计算 r13 + r15 + 2 的地址，并将结果加载到 rax 中

    WORD $0xff49; BYTE $0xc7     // inc    r15
    // 将 r15 的值增加 1

    WORD $0x014d; BYTE $0xfe     // add    r14, r15
    // 将 r14 的值增加 r15 的值

    JMP  LBB0_29            // 跳转到标签 LBB0_29

LBB0_8: // 标签 LBB0_8，表示代码的另一个分支
    LONG $0x000020be; BYTE $0x00               // mov    esi, 32
    // 将 32 移动到 esi 寄存器中，可能用于初始化某个计数

    LONG $0x15ff8341                           // cmp    r15d, 21
    // 将 r15d 的值与 21 进行比较

    JB   LBB0_10            // 如果 r15d < 21，跳转到标签 LBB0_10

    LONG $0xec478d41                           // lea    eax, [r15 - 20]
    // 计算 r15 - 20 的地址，并将结果加载到 eax 中

    LONG $0x7475c1c4; WORD $0x0554; BYTE $0x00 // vpcmpeqb    ymm2, ymm1, yword [r13 + rax]
    // 使用 SIMD 指令比较 ymm1 和从 r13 + rax 指向的内存加载的数据，结果存储在 ymm2 中

    LONG $0xc2d7fdc5                           // vpmovmskb    eax, ymm2
    // 将 ymm2 中的掩码移动到 eax 中

    LONG $0xbc0f48f3; BYTE $0xf0               // tzcnt    rsi, rax
    // 计算 eax 中最低有效位的零计数，并将结果存储在 rsi 中

    WORD $0xc085                               // test    eax, eax
    // 测试 eax 的值，设置标志位

    LONG $0x000020b8; BYTE $0x00               // mov    eax, 32
    // 将 32 移动到 eax 中

    WORD $0x440f; BYTE $0xf0                   // cmove    esi, eax
    // 如果之前的测试结果为零，则将 eax 的值移动到 esi 中

    LONG $0x3e748d42; BYTE $0xec               // lea    esi, [rsi + r15 - 20]
    // 计算 rsi + r15 - 20 的地址，并将结果加载到 esi 中

LBB0_10: // 标签 LBB0_10，表示代码的另一个分支
    WORD $0x2944; BYTE $0xfe // sub    esi, r15d
    // 从 esi 中减去 r15d 的值

    WORD $0xfe83; BYTE $0x06 // cmp    esi, 6
    // 将 esi 的值与 6 进行比较

    JB   LBB0_30            // 如果 esi < 6，跳转到标签 LBB0_30

LBB0_11: // 标签 LBB0_11，表示代码的一个分支
    WORD $0x014d; BYTE $0xfd                   // add    r13, r15
    // 将 r15 的值加到 r13 中，可能用于更新字符串的当前位置

    LONG $0x45b60f41; BYTE $0x02               // movzx    eax, byte [r13 + 2]
    // 从 r13 + 2 的内存地址加载一个字节到 eax 中，并进行零扩展

    LONG $0x04be0f46; BYTE $0x08               // movsx    r8d, byte [rax + r9]
    // 从 rax + r9 的内存地址加载一个字节到 r8d 中，并进行符号扩展

    LONG $0x5db60f41; BYTE $0x03               // movzx    ebx, byte [r13 + 3]
    // 从 r13 + 3 的内存地址加载一个字节到 ebx 中，并进行零扩展

    LONG $0x1cbe0f42; BYTE $0x0b               // movsx    ebx, byte [rbx + r9]
    // 从 rbx + r9 的内存地址加载一个字节到 ebx 中，并进行符号扩展

    LONG $0x45b60f41; BYTE $0x04               // movzx    eax, byte [r13 + 4]
    // 从 r13 + 4 的内存地址加载一个字节到 eax 中，并进行零扩展

    LONG $0x24be0f46; BYTE $0x08               // movsx    r12d, byte [rax + r9]
    // 从 rax + r9 的内存地址加载一个字节到 r12d 中，并进行符号扩展

    LONG $0x45b60f41; BYTE $0x05               // movzx    eax, byte [r13 + 5]
    // 从 r13 + 5 的内存地址加载一个字节到 eax 中，并进行零扩展

    LONG $0x04be0f42; BYTE $0x08               // movsx    eax, byte [rax + r9]
    // 从 rax + r9 的内存地址加载一个字节到 eax 中，并进行符号扩展

    LONG $0x0ce0c141                           // shl    r8d, 12
    // 将 r8d 左移 12 位

    WORD $0xe3c1; BYTE $0x08                   // shl    ebx, 8
    // 将 ebx 左移 8 位

    WORD $0x0944; BYTE $0xc3                   // or    ebx, r8d
    // 将 ebx 和 r8d 进行按位或操作

    LONG $0x04e4c141                           // shl    r12d, 4
    // 将 r12d 左移 4 位

    WORD $0x0941; BYTE $0xc4                   // or    r12d, eax
    // 将 r12d 和 eax 进行按位或操作

    WORD $0x0941; BYTE $0xdc                   // or    r12d, ebx
    // 将 r12d 和 ebx 进行按位或操作

    LONG $0x06458d49                           // lea    rax, [r13 + 6]
    // 计算 r13 + 6 的地址，并将结果加载到 rax 中

    WORD $0x8944; BYTE $0xe3                   // mov    ebx, r12d
    // 将 r12d 的值移动到 ebx 中

    LONG $0xfc00e381; WORD $0xffff             // and    ebx, -1024
    // 将 ebx 与 -1024 进行按位与操作，清除低 10 位

    LONG $0xd800fb81; WORD $0x0000             // cmp    ebx, 55296
    // 将 ebx 的值与 55296 进行比较

    JE   LBB0_12                               // 如果相等，跳转到标签 LBB0_12

    LONG $0x80fc8141; WORD $0x0000; BYTE $0x00 // cmp    r12d, 128
    // 将 r12d 的值与 128 进行比较

    JAE  LBB0_19                               // 如果 r12d >= 128，跳转到标签 LBB0_19

LBB0_18: // 标签 LBB0_18，表示代码的另一个分支
    LONG $0x000001be; BYTE $0x00 // mov    esi, 1
    // 将 1 移动到 esi 中

    JMP  LBB0_25                               // 跳转到标签 LBB0_25

LBB0_12: // 标签 LBB0_12，表示代码的另一个分支
    WORD $0xfe83; BYTE $0x0c                   // cmp    esi, 12
    // 将 esi 的值与 12 进行比较

    JB   LBB0_30                               // 如果 esi < 12，跳转到标签 LBB0_30

    WORD $0x3880; BYTE $0x5c                   // cmp    byte [rax], 92
    // 比较 rax 指向的字节是否为 92

    JNE  LBB0_30                               // 如果不相等，跳转到标签 LBB0_30

    LONG $0x077d8041; BYTE $0x75               // cmp    byte [r13 + 7], 117
    // 比较 r13 + 7 指向的字节是否为 117

    JNE  LBB0_30                               // 如果不相等，跳转到标签 LBB0_30

    LONG $0x45b60f41; BYTE $0x08               // movzx    eax, byte [r13 + 8]
    // 从 r13 + 8 的内存地址加载一个字节到 eax 中，并进行零扩展

    LONG $0x04be0f46; BYTE $0x08               // movsx    r8d, byte [rax + r9]
    // 从 rax + r9 的内存地址加载一个字节到 r8d 中，并进行符号扩展

    LONG $0x75b60f41; BYTE $0x09               // movzx    esi, byte [r13 + 9]
    // 从 r13 + 9 的内存地址加载一个字节到 esi 中，并进行零扩展

    LONG $0x1cbe0f42; BYTE $0x0e               // movsx    ebx, byte [rsi + r9]
    // 从 rsi + r9 的内存地址加载一个字节到 ebx 中，并进行符号扩展

    LONG $0x75b60f41; BYTE $0x0a               // movzx    esi, byte [r13 + 10]
    // 从 r13 + 10 的内存地址加载一个字节到 esi 中，并进行零扩展

    LONG $0x34be0f42; BYTE $0x0e               // movsx    esi, byte [rsi + r9]
    // 从 rsi + r9 的内存地址加载一个字节到 esi 中，并进行符号扩展

    LONG $0x45b60f41; BYTE $0x0b               // movzx    eax, byte [r13 + 11]
    // 从 r13 + 11 的内存地址加载一个字节到 eax 中，并进行零扩展

    LONG $0x04be0f42; BYTE $0x08               // movsx    eax, byte [rax + r9]
    // 从 rax + r9 的内存地址加载一个字节到 eax 中，并进行符号扩展

    LONG $0x0ce0c141                           // shl    r8d, 12
    // 将 r8d 左移 12 位

    WORD $0xe3c1; BYTE $0x08                   // shl    ebx, 8
    // 将 ebx 左移 8 位

    WORD $0x0944; BYTE $0xc3                   // or    ebx, r8d
    // 将 ebx 和 r8d 进行按位或操作

    WORD $0xe6c1; BYTE $0x04                   // shl    esi, 4
    // 将 esi 左移 4 位

    WORD $0xc609                               // or    esi, eax
    // 将 esi 和 eax 进行按位或操作

    WORD $0xde09                               // or    esi, ebx
    // 将 esi 和 ebx 进行按位或操作

    WORD $0xf089                               // mov    eax, esi
    // 将 esi 的值移动到 eax 中

    WORD $0x0944; BYTE $0xe0                   // or    eax, r12d
    // 将 eax 和 r12d 进行按位或操作

    LONG $0x00ffff3d; BYTE $0x00               // cmp    eax, 65535
    // 将 eax 的值与 65535 进行比较

    JA   LBB0_30                               // 如果 eax > 65535，跳转到标签 LBB0_30

    LONG $0x0ae4c141                           // shl    r12d, 10
    // 将 r12d 左移 10 位

    LONG $0x00c48141; WORD $0xa000; BYTE $0xfc // add    r12d, -56623104
    // 将 r12d 加上 -56623104

    LONG $0x2400c681; WORD $0xffff             // add    esi, -56320
    // 将 esi 加上 -56320

    WORD $0x0944; BYTE $0xe6                   // or    esi, r12d
    // 将 esi 和 r12d 进行按位或操作

    LONG $0x0000c681; WORD $0x0001             // add    esi, 65536
    // 将 esi 加上 65536

    LONG $0x0cc58349                           // add    r13, 12
    // 将 12 加到 r13 中，更新字符串位置

    WORD $0x894c; BYTE $0xe8                   // mov    rax, r13
    // 将 r13 的值移动到 rax 中

    WORD $0x8941; BYTE $0xf4                   // mov    r12d, esi
    // 将 esi 的值移动到 r12d 中

    LONG $0x80fc8141; WORD $0x0000; BYTE $0x00 // cmp    r12d, 128
    // 将 r12d 的值与 128 进行比较

    JB   LBB0_18                               // 如果 r12d < 128，跳转到标签 LBB0_18

LBB0_19: // 标签 LBB0_19，表示代码的另一个分支
    LONG $0x00fc8141; WORD $0x0008; BYTE $0x00 // cmp    r12d, 2048
    // 将 r12d 的值与 2048 进行比较

    JAE  LBB0_21                               // 如果 r12d >= 2048，跳转到标签 LBB0_21

    LONG $0x000002be; BYTE $0x00               // mov    esi, 2
    // 将 2 移动到 esi 中

    JMP  LBB0_25                               // 跳转到标签 LBB0_25

LBB0_21: // 标签 LBB0_21，表示代码的另一个分支
    LONG $0x00fc8141; WORD $0x0100; BYTE $0x00 // cmp    r12d, 65536
    // 将 r12d 的值与 65536 进行比较

    JAE  LBB0_23                               // 如果 r12d >= 65536，跳转到标签 LBB0_23

    LONG $0x000003be; BYTE $0x00               // mov    esi, 3
    // 将 3 移动到 esi 中

    JMP  LBB0_25                               // 跳转到标签 LBB0_25

LBB0_23: // 标签 LBB0_23，表示代码的另一个分支
    LONG $0xfffc8141; WORD $0x10ff; BYTE $0x00 // cmp    r12d, 1114111
    // 将 r12d 的值与 1114111 进行比较

    JA   LBB0_30                               // 如果 r12d > 1114111，跳转到标签 LBB0_30

    LONG $0x000004be; BYTE $0x00               // mov    esi, 4
    // 将 4 移动到 esi 中

LBB0_25: // 标签 LBB0_25，表示代码的另一个分支
    WORD $0x014d; BYTE $0xfe // add    r14, r15
    WORD $0x0149; BYTE $0xf6 // add    r14, rsi

LBB0_29:
    WORD $0x8948; BYTE $0xc6 // mov    rsi, rax
    WORD $0x2948; BYTE $0xfe // sub    rsi, rdi
    WORD $0x8949; BYTE $0xc5 // mov    r13, rax
    WORD $0x394c; BYTE $0xde // cmp    rsi, r11
    JB   LBB0_2

LBB0_30:
    WORD $0xc031 // xor    eax, eax
    JMP  LBB0_31

LBB0_3:
    WORD $0x8944; BYTE $0xe0     // mov    eax, r12d
    LONG $0xbc0f48f3; BYTE $0xc0 // tzcnt    rax, rax
    WORD $0x0148; BYTE $0xc6     // add    rsi, rax
    WORD $0x8948; BYTE $0x32     // mov    qword [rdx], rsi
    WORD $0x0149; BYTE $0xc6     // add    r14, rax
    WORD $0x894c; BYTE $0x31     // mov    qword [rcx], r14
    WORD $0x01b0                 // mov    al, 1

LBB0_31:
    VZEROUPPER
    MOVQ AX, result+32(FP)
    RET

TEXT ·_parse_string(SB), $8-32

    MOVQ src+0(FP), DI
    MOVQ dst+8(FP), SI
    MOVQ pcurrent_string_buf_loc+16(FP), DX
    LEAQ LCDATA1<>(SB), BP

    LONG $0x076ffec5             // vmovdqu    ymm0, yword [rdi]
    LONG $0x067ffec5             // vmovdqu    yword [rsi], ymm0
    LONG $0x4d74fdc5; BYTE $0x00 // vpcmpeqb    ymm1, ymm0, yword 0[rbp] /* [rip + LCPI0_0] */
    LONG $0xc9d7fdc5             // vpmovmskb    ecx, ymm1
    LONG $0x4574fdc5; BYTE $0x20 // vpcmpeqb    ymm0, ymm0, yword 32[rbp] /* [rip + LCPI0_1] */
    LONG $0xf0d77dc5             // vpmovmskb    r14d, ymm0
    WORD $0x418d; BYTE $0xff     // lea    eax, [rcx - 1]
    WORD $0x8544; BYTE $0xf0     // test    eax, r14d
    JE   LBB0_3

LBB0_1:
    WORD $0x8944; BYTE $0xf0     // mov    eax, r14d
    LONG $0xbc0f48f3; BYTE $0xc0 // tzcnt    rax, rax
    WORD $0x0148; BYTE $0xf0     // add    rax, rsi
    WORD $0x8948; BYTE $0x02     // mov    qword [rdx], rax
    LONG $0x000001b8; BYTE $0x00 // mov    eax, 1

LBB0_2: // 标签 LBB0_2，表示代码的一个分支
    VZEROUPPER // 清除 SIMD 寄存器的上半部分，避免潜在的性能损失
    // 该指令用于确保在使用 SSE 和 AVX 指令集时，避免由于寄存器状态不一致而导致的性能下降。

    MOVQ AX, res+24(FP) // 将 AX 寄存器的值移动到栈帧中的 res+24 位置
    // 这里将结果存储到函数返回值的位置，res 是一个指向结果的指针。

    RET // 返回到调用者
    // 结束当前函数的执行，并将控制权返回给调用该函数的代码。

LBB0_3:
    LONG $0x456ffdc5; BYTE $0x00               // vmovdqa    ymm0, yword 0[rbp] /* [rip + LCPI0_0] */
    LONG $0x4d6ffdc5; BYTE $0x20               // vmovdqa    ymm1, yword 32[rbp] /* [rip + LCPI0_1] */
    WORD $0xc031                               // xor    eax, eax
    LONG $0x40658d4c                           // lea    r12, 64[rbp] /* [rip + __ZL10digittoval] */
    LONG $0x0001b941; WORD $0x0000             // mov    r9d, 1
    LONG $0x0002ba41; WORD $0x0000             // mov    r10d, 2
    LONG $0x40bd8d4c; WORD $0x0001; BYTE $0x00 // lea    r15, 320[rbp] /* [rip + __ZL10escape_map] */
    JMP  LBB0_4

LBB0_24:
    LONG $0xfff88141; WORD $0x00ff; BYTE $0x00 // cmp    r8d, 65535
    JA   LBB0_26
    WORD $0x8944; BYTE $0xc1                   // mov    ecx, r8d
    WORD $0xe9c1; BYTE $0x0c                   // shr    ecx, 12
    LONG $0x00e0c181; WORD $0x0000             // add    ecx, 224
    WORD $0x0e88                               // mov    byte [rsi], cl
    WORD $0x8944; BYTE $0xc1                   // mov    ecx, r8d
    WORD $0xe9c1; BYTE $0x06                   // shr    ecx, 6
    WORD $0xe180; BYTE $0x3f                   // and    cl, 63
    WORD $0xc980; BYTE $0x80                   // or    cl, -128
    WORD $0x4e88; BYTE $0x01                   // mov    byte [rsi + 1], cl
    LONG $0x3fe08041                           // and    r8b, 63
    LONG $0x80c88041                           // or    r8b, -128
    LONG $0x02468844                           // mov    byte [rsi + 2], r8b
    LONG $0x000003b9; BYTE $0x00               // mov    ecx, 3
    JMP  LBB0_28

LBB0_26:
    LONG $0xfff88141; WORD $0x10ff; BYTE $0x00 // cmp    r8d, 1114111
    JA   LBB0_2
    WORD $0x8944; BYTE $0xc1                   // mov    ecx, r8d
    WORD $0xe9c1; BYTE $0x12                   // shr    ecx, 18
    LONG $0x00f0c181; WORD $0x0000             // add    ecx, 240
    WORD $0x0e88                               // mov    byte [rsi], cl
    WORD $0x8944; BYTE $0xc1                   // mov    ecx, r8d
    WORD $0xe9c1; BYTE $0x0c                   // shr    ecx, 12
    WORD $0xe180; BYTE $0x3f                   // and    cl, 63
    WORD $0xc980; BYTE $0x80                   // or    cl, -128
    WORD $0x4e88; BYTE $0x01                   // mov    byte [rsi + 1], cl
    WORD $0x8944; BYTE $0xc1                   // mov    ecx, r8d
    WORD $0xe9c1; BYTE $0x06                   // shr    ecx, 6
    WORD $0xe180; BYTE $0x3f                   // and    cl, 63
    WORD $0xc980; BYTE $0x80                   // or    cl, -128
    WORD $0x4e88; BYTE $0x02                   // mov    byte [rsi + 2], cl
    LONG $0x3fe08041                           // and    r8b, 63
    LONG $0x80c88041                           // or    r8b, -128
    LONG $0x03468844                           // mov    byte [rsi + 3], r8b
    LONG $0x000004b9; BYTE $0x00               // mov    ecx, 4
    JMP  LBB0_28

LBB0_4:
    LONG $0xff5e8d41               // lea    ebx, [r14 - 1]
    WORD $0xcb85                   // test    ebx, ecx
    JE   LBB0_8
    WORD $0xc989                   // mov    ecx, ecx
    LONG $0xbc0f4cf3; BYTE $0xd9   // tzcnt    r11, rcx
    LONG $0x4cb60f42; WORD $0x011f // movzx    ecx, byte [rdi + r11 + 1]
    LONG $0x75f98348               // cmp    rcx, 117
    JNE  LBB0_9
    WORD $0x8545; BYTE $0xf6       // test    r14d, r14d
    JE   LBB0_11
    WORD $0x8944; BYTE $0xf1       // mov    ecx, r14d
    LONG $0xbc0f4cf3; BYTE $0xf1   // tzcnt    r14, rcx
    WORD $0x2945; BYTE $0xde       // sub    r14d, r11d
    LONG $0x06fe8341               // cmp    r14d, 6
    JAE  LBB0_14
    JMP  LBB0_2

LBB0_8:
    LONG $0x20c78348         // add    rdi, 32
    LONG $0x20c68348         // add    rsi, 32
    WORD $0x8949; BYTE $0xfd // mov    r13, rdi
    JMP  LBB0_29

LBB0_9:
    LONG $0x0cb60f42; BYTE $0x39 // movzx    ecx, byte [rcx + r15]
    WORD $0xc984                 // test    cl, cl
    JE   LBB0_2
    LONG $0x1e0c8842             // mov    byte [rsi + r11], cl
    LONG $0x1f6c8d4e; BYTE $0x02 // lea    r13, [rdi + r11 + 2]
    LONG $0x014b8d49             // lea    rcx, [r11 + 1]

LBB0_28:
    WORD $0x0148; BYTE $0xce // add    rsi, rcx
    JMP  LBB0_29

LBB0_11:
    LONG $0x0020be41; WORD $0x0000 // mov    r14d, 32
    LONG $0x15fb8341               // cmp    r11d, 21
    JB   LBB0_13
    LONG $0xec4b8d41               // lea    ecx, [r11 - 20]
    LONG $0x1474f5c5; BYTE $0x0f   // vpcmpeqb    ymm2, ymm1, yword [rdi + rcx]
    LONG $0xcad7fdc5               // vpmovmskb    ecx, ymm2
    LONG $0xbc0f48f3; BYTE $0xd9   // tzcnt    rbx, rcx
    WORD $0xc985                   // test    ecx, ecx
    LONG $0x000020b9; BYTE $0x00   // mov    ecx, 32
    WORD $0x440f; BYTE $0xd9       // cmove    ebx, ecx
    LONG $0x1b748d46; BYTE $0xec   // lea    r14d, [rbx + r11 - 20]

LBB0_13:
    WORD $0x2945; BYTE $0xde // sub    r14d, r11d
    LONG $0x06fe8341         // cmp    r14d, 6
    JB   LBB0_2

LBB0_14:
    WORD $0x014c; BYTE $0xdf                   // add    rdi, r11
    LONG $0x024fb60f                           // movzx    ecx, byte [rdi + 2]
    LONG $0x2cbe0f46; BYTE $0x21               // movsx    r13d, byte [rcx + r12]
    LONG $0x035fb60f                           // movzx    ebx, byte [rdi + 3]
    LONG $0x1cbe0f42; BYTE $0x23               // movsx    ebx, byte [rbx + r12]
    LONG $0x044fb60f                           // movzx    ecx, byte [rdi + 4]
    LONG $0x04be0f46; BYTE $0x21               // movsx    r8d, byte [rcx + r12]
    LONG $0x054fb60f                           // movzx    ecx, byte [rdi + 5]
    LONG $0x0cbe0f42; BYTE $0x21               // movsx    ecx, byte [rcx + r12]
    LONG $0x0ce5c141                           // shl    r13d, 12
    WORD $0xe3c1; BYTE $0x08                   // shl    ebx, 8
    WORD $0x0944; BYTE $0xeb                   // or    ebx, r13d
    LONG $0x04e0c141                           // shl    r8d, 4
    WORD $0x0941; BYTE $0xc8                   // or    r8d, ecx
    WORD $0x0941; BYTE $0xd8                   // or    r8d, ebx
    LONG $0x066f8d4c                           // lea    r13, [rdi + 6]
    WORD $0x8944; BYTE $0xc1                   // mov    ecx, r8d
    LONG $0xfc00e181; WORD $0xffff             // and    ecx, -1024
    LONG $0xd800f981; WORD $0x0000             // cmp    ecx, 55296
    JNE  LBB0_20
    LONG $0x0cfe8341                           // cmp    r14d, 12
    JB   LBB0_2
    LONG $0x007d8041; BYTE $0x5c               // cmp    byte [r13], 92
    JNE  LBB0_2
    LONG $0x75077f80                           // cmp    byte [rdi + 7], 117
    JNE  LBB0_2
    LONG $0x084fb60f                           // movzx    ecx, byte [rdi + 8]
    LONG $0x34be0f46; BYTE $0x21               // movsx    r14d, byte [rcx + r12]
    LONG $0x094fb60f                           // movzx    ecx, byte [rdi + 9]
    LONG $0x2cbe0f46; BYTE $0x21               // movsx    r13d, byte [rcx + r12]
    LONG $0x0a4fb60f                           // movzx    ecx, byte [rdi + 10]
    LONG $0x0cbe0f42; BYTE $0x21               // movsx    ecx, byte [rcx + r12]
    LONG $0x0b5fb60f                           // movzx    ebx, byte [rdi + 11]
    LONG $0x1cbe0f42; BYTE $0x23               // movsx    ebx, byte [rbx + r12]
    LONG $0x0ce6c141                           // shl    r14d, 12
    LONG $0x08e5c141                           // shl    r13d, 8
    WORD $0x0945; BYTE $0xf5                   // or    r13d, r14d
    WORD $0xe1c1; BYTE $0x04                   // shl    ecx, 4
    WORD $0xd909                               // or    ecx, ebx
    WORD $0x0944; BYTE $0xe9                   // or    ecx, r13d
    WORD $0xcb89                               // mov    ebx, ecx
    WORD $0x0944; BYTE $0xc3                   // or    ebx, r8d
    LONG $0xfffffb81; WORD $0x0000             // cmp    ebx, 65535
    JA   LBB0_30
    LONG $0x0ae0c141                           // shl    r8d, 10
    LONG $0x00c08141; WORD $0xa000; BYTE $0xfc // add    r8d, -56623104
    LONG $0x2400c181; WORD $0xffff             // add    ecx, -56320
    WORD $0x0944; BYTE $0xc1                   // or    ecx, r8d
    LONG $0x0000c181; WORD $0x0001             // add    ecx, 65536
    LONG $0x0cc78348                           // add    rdi, 12
    WORD $0x8949; BYTE $0xfd                   // mov    r13, rdi
    WORD $0x8941; BYTE $0xc8                   // mov    r8d, ecx

LBB0_20:
    WORD $0x014c; BYTE $0xde // add    rsi, r11
    LONG $0x7ff88341         // cmp    r8d, 127
    JA   LBB0_22
    WORD $0x8844; BYTE $0x06 // mov    byte [rsi], r8b
    WORD $0x014c; BYTE $0xce // add    rsi, r9
    JMP  LBB0_29

LBB0_22:
    LONG $0xfff88141; WORD $0x0007; BYTE $0x00 // cmp    r8d, 2047
    JA   LBB0_24
    WORD $0x8944; BYTE $0xc1                   // mov    ecx, r8d
    WORD $0xe9c1; BYTE $0x06                   // shr    ecx, 6
    LONG $0x00c0c181; WORD $0x0000             // add    ecx, 192
    WORD $0x0e88                               // mov    byte [rsi], cl
    LONG $0x3fe08041                           // and    r8b, 63
    LONG $0x80c88041                           // or    r8b, -128
    LONG $0x01468844                           // mov    byte [rsi + 1], r8b
    WORD $0x014c; BYTE $0xd6                   // add    rsi, r10

LBB0_29: // 标签 LBB0_29，表示代码的一个分支
    LONG $0x6f7ec1c4; WORD $0x0055 // vmovdqu    ymm2, yword [r13]
    // 从 r13 指向的内存地址加载 256 位数据到 ymm2 寄存器
    // vmovdqu 指令用于无对齐加载数据，适用于处理不对齐的内存访问。

    LONG $0x167ffec5               // vmovdqu    yword [rsi], ymm2
    // 将 ymm2 寄存器中的数据存储到 rsi 指向的内存地址
    // 这将把之前加载的数据写入到目标内存中。

    LONG $0xd874edc5               // vpcmpeqb    ymm3, ymm2, ymm0
    // 比较 ymm2 和 ymm0 中的字节，结果存储在 ymm3 中
    // 如果对应字节相等，则 ymm3 中的相应字节为 0xFF，否则为 0x00。

    LONG $0xcbd7fdc5               // vpmovmskb    ecx, ymm3
    // 将 ymm3 中的掩码（0xFF 和 0x00）移动到 ecx 寄存器中
    // ecx 中的每一位表示对应字节是否相等。

    LONG $0xd174edc5               // vpcmpeqb    ymm2, ymm2, ymm1
    // 再次比较 ymm2 和 ymm1 中的字节，结果存储在 ymm2 中
    // 这一步可能用于检查与另一个数据集的相等性。

    LONG $0xf2d77dc5               // vpmovmskb    r14d, ymm2
    // 将 ymm2 中的掩码移动到 r14d 寄存器中
    // r14d 中的每一位表示与 ymm1 中的字节的比较结果。

    WORD $0x598d; BYTE $0xff       // lea    ebx, [rcx - 1]
    // 计算 rcx 的值减去 1，结果存储在 ebx 中
    // 这可能用于后续的条件判断。

    WORD $0x894c; BYTE $0xef       // mov    rdi, r13
    // 将 r13 的值移动到 rdi 中
    // rdi 可能用于后续的内存操作或函数调用。

    WORD $0x8544; BYTE $0xf3       // test    ebx, r14d
    // 测试 ebx 和 r14d 的值，设置标志位
    // 这一步用于检查 ebx 和 r14d 的位是否有重叠。

    JE   LBB0_4                    // 如果相等，跳转到标签 LBB0_4
    // 如果 ebx 和 r14d 的测试结果为零，则跳转到 LBB0_4。

    JMP  LBB0_1                    // 否则跳转到标签 LBB0_1
    // 如果不相等，则继续执行 LBB0_1 中的代码。
    